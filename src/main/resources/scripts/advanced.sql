------------TEST DATA
INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    VALUES (1, 1, TO_DATE('2025-01-01','YYYY-MM-DD'), TO_DATE('2025-01-02','YYYY-MM-DD'), 1, 1);
INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    VALUES (2, 1, TO_DATE('2025-01-30','YYYY-MM-DD'), TO_DATE('2025-02-02','YYYY-MM-DD'), 1, 1);
INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    VALUES (3, 1, TO_DATE('2025-01-01','YYYY-MM-DD'), TO_DATE('2025-01-11','YYYY-MM-DD'), 10, 1);
INSERT INTO REQUEST_APPROVALS (REQUEST_APPROVAL_ID, DATE_CREATED, IS_APPROVED, REQUEST_ID) VALUES (1, SYSDATE, 1, 1);
INSERT INTO REQUEST_APPROVALS (REQUEST_APPROVAL_ID, DATE_CREATED, IS_APPROVED, REQUEST_ID) VALUES (2, TO_DATE('2025-01-01','YYYY-MM-DD'), 0, 3);
------------RESULT TABLES
CREATE TABLE AVG_PRICE_PER_USER(
    OWNER_ID NUMBER(4) NOT NULL,
    AVG_PRICE DECIMAL(7, 1) NOT NULL
);
CREATE TABLE AVG_GRADE(
    COTTAGE_NAME VARCHAR2(100) NOT NULL,
    AVG_GRADE NUMBER NOT NULL
);
CREATE TABLE REQUEST_PER_CITY(
    CITY_NAME VARCHAR2(20) NOT NULL,
    TOTAL_REQ NUMBER NOT NULL
);

-- ---------FUNCTIONS  -> IN ORACLE
CREATE OR REPLACE FUNCTION IS_GRADE_GOOD(V_GRADE NUMBER)
RETURN NUMBER
AS
    V_RESULT NUMBER;
BEGIN
    IF V_GRADE > 3 THEN
        V_RESULT := 1;
    ELSE
        V_RESULT := 0;
    END IF;
    RETURN V_RESULT;
END;


CREATE OR REPLACE FUNCTION REQUEST_STATUS(P_REQUEST_ID NUMBER)
RETURN VARCHAR2
AS
    V_IS_APPROVED NUMBER;
BEGIN
    SELECT RA.IS_APPROVED
    INTO V_IS_APPROVED
    FROM REQUESTS R
    LEFT JOIN REQUEST_APPROVALS RA ON RA.REQUEST_ID = R.REQUEST_ID
    WHERE R.REQUEST_ID = P_REQUEST_ID;

    IF V_IS_APPROVED = 1 THEN
        RETURN 'Accepted';
    ELSIF V_IS_APPROVED = 0 THEN
        RETURN 'Rejected';
    ELSE
        RETURN 'Pending';
    END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN RETURN 'Null';
END;

CREATE OR REPLACE FUNCTION CALCULATE_TOTAL_TAX(P_REQUEST_ID NUMBER)
RETURN NUMBER
AS
  V_DAYS  NUMBER;
  V_TOTAL_PRICE  DECIMAL(7, 2) := 0;
  V_PRICE_PER_DAY DECIMAL(7, 2);
  V_COTTAGE_ID NUMBER;
  V_TOTAL_TAX DECIMAL(7, 2) := 0;
  V_FIRST_WEEK_TAX DECIMAL(7, 2) := 0;
  V_SECOND_WEEK_TAX DECIMAL(7, 2) := 0;
BEGIN
        SELECT (CHECKOUT_DATE - CHECKIN_DATE), COTTAGE_ID
        INTO   V_DAYS, V_COTTAGE_ID
        FROM   REQUESTS
        WHERE  REQUEST_id = P_REQUEST_ID;

        SELECT MIN_PRICE_PER_DAY
        INTO V_PRICE_PER_DAY
        FROM COTTAGES
        WHERE COTTAGE_ID = V_COTTAGE_ID;

    V_TOTAL_PRICE := V_DAYS * V_PRICE_PER_DAY;
    V_FIRST_WEEK_TAX := 0.36 * 7 + 0.33 * 7* V_PRICE_PER_DAY;
    V_SECOND_WEEK_TAX := 0.26 * 7 + 0.23 * 7* V_PRICE_PER_DAY;
    IF V_DAYS = 1 THEN
        V_TOTAL_TAX := 10;
    ELSIF V_DAYS < 7 THEN
        V_TOTAL_TAX := 0.36 * V_DAYS + 0.33 * V_TOTAL_PRICE;
    ELSIF V_DAYS < 14 THEN
        V_TOTAL_TAX := V_FIRST_WEEK_TAX + 0.26 * (V_DAYS - 7) + 0.23 * (V_DAYS - 7) * V_PRICE_PER_DAY;
    ELSE
        V_TOTAL_TAX := V_FIRST_WEEK_TAX + V_SECOND_WEEK_TAX + 0.15 * (V_DAYS - 14) + 0.12 * (V_DAYS - 14) * V_PRICE_PER_DAY;
    END IF;

    RETURN V_TOTAL_TAX;
END;

CREATE OR REPLACE FUNCTION AVG_PRICE_IN_COUNTRY_WITH_TAX (P_COUNTRY_ID LONG)
RETURN NUMBER
AS
  V_AVG_PRICE  DECIMAL(7, 2) := 0;
  V_MIN_PRICE  DECIMAL(7, 2) := 0;
  V_TOTAL_PRICE  DECIMAL(7, 2) := 0;
BEGIN
    SELECT AVG(TOTAL_PRICE) INTO V_AVG_PRICE
    FROM REQUESTS JOIN COTTAGES USING (COTTAGE_ID)
    JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    WHERE COUNTRY_ID = P_COUNTRY_ID;

    SELECT MIN(MIN_PRICE_PER_DAY) INTO V_MIN_PRICE
    FROM COTTAGES JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    WHERE COUNTRY_ID = P_COUNTRY_ID;

    IF V_MIN_PRICE > 30 THEN
        V_TOTAL_PRICE := V_AVG_PRICE + V_MIN_PRICE;
    ELSIF  V_MIN_PRICE > 10 THEN
        V_TOTAL_PRICE := V_AVG_PRICE + V_MIN_PRICE * 2;
    ELSE
        V_TOTAL_PRICE := V_AVG_PRICE;
    END IF;
    RETURN V_TOTAL_PRICE;
END;

--checks whether the cottage is available during the specified time
CREATE OR REPLACE FUNCTION IS_COTTAGE_AVAILABLE(
    P_COTTAGE_ID NUMBER,
    P_CHECKIN_DATE DATE,
    P_CHECKOUT_DATE DATE
) RETURN NUMBER IS
    V_CONFLICTING_REQUESTS NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO V_CONFLICTING_REQUESTS
    FROM REQUESTS R
    JOIN REQUEST_APPROVALS RA ON R.REQUEST_ID = RA.REQUEST_ID
    WHERE R.COTTAGE_ID = P_COTTAGE_ID
      AND RA.IS_APPROVED = 1
      AND (
           (R.CHECKIN_DATE <= P_CHECKIN_DATE AND R.CHECKOUT_DATE >= P_CHECKIN_DATE) OR
           (R.CHECKIN_DATE <= P_CHECKOUT_DATE AND R.CHECKOUT_DATE >= P_CHECKOUT_DATE) OR
           (R.CHECKIN_DATE >= P_CHECKIN_DATE AND R.CHECKOUT_DATE <= P_CHECKOUT_DATE)
      );

    IF V_CONFLICTING_REQUESTS = 0 THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;
END;


-- FUNCTION CHECK
SELECT IS_GRADE_GOOD(5) from dual;
SELECT IS_GRADE_GOOD(3) from dual;

SELECT REQUEST_ID, REQUEST_STATUS(REQUEST_ID) AS STATUS FROM REQUESTS;

SELECT CALCULATE_TOTAL_TAX(1) FROM dual;
SELECT CALCULATE_TOTAL_TAX(4) FROM dual;

SELECT AVG_PRICE_IN_COUNTRY_WITH_TAX(1) FROM dual;

-- ---------PROCEDURES
CREATE OR REPLACE PROCEDURE MAKE_REVIEWS(P_COTTAGE_ID LONG)
AS
    V_REVIEW NUMBER (4);
BEGIN
    FOR i IN 1..100000 LOOP
        INSERT INTO REVIEWS (REVIEW_ID, COTTAGE_ID, AUTHOR_ID, TEXT, DATE_POSTED, GRADE)
            VALUES (REVIEWS_SEQ.NEXTVAL, P_COTTAGE_ID, 1, Null, sysdate-dbms_random.value(1,10000), dbms_random.value(1,5));
    END LOOP;
    COMMIT;
END;

select count(*) from reviews;
exec make_reviews(1);
CREATE OR REPLACE PROCEDURE MAKE_cottages(P_COTTAGE_ID LONG)
AS
    V_REVIEW NUMBER (4);
BEGIN
    FOR i IN 1..50000 LOOP
        INSERT INTO COTTAGES (COTTAGE_ID, NAME, ADDRESS_ID, SIZE_M2, BATHROOMS_NUMBER, ROOMS_NUMBER, MAX_PEOPLE_NUM, MIN_PRICE_PER_DAY, OWNER_ID)
    VALUES (COTTAGES_SEQ.NEXTVAL, 'cottage'||i, 1, dbms_random.value(1,10000), dbms_random.value(1,10000), dbms_random.value(1,10000), dbms_random.value(1,10000), dbms_random.value(1,10000), 2);
    END LOOP;
    COMMIT;
END;

CREATE OR REPLACE PROCEDURE MAKE_requests(P_COTTAGE_ID LONG)
AS
    V_REVIEW NUMBER (4);
BEGIN
    FOR i IN 1..50000 LOOP
    -- INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    -- VALUES (REQUESTS_SEQ.nextval, dbms_random.value(1, 50000), sysdate-dbms_random.value(10, 15), sysdate-dbms_random.value(1, 5), dbms_random.value(1, 100), 1);  
    INSERT INTO REQUEST_APPROVALS (REQUEST_APPROVAL_ID, DATE_CREATED, IS_APPROVED, REQUEST_ID) VALUES (REQUEST_APPROVALS_SEQ.nextval, SYSDATE-dbms_random.value(10, 15), dbms_random.value(0, 1), dbms_random.value(1, 50000));
    END LOOP;
    COMMIT;
END;

CREATE OR REPLACE PROCEDURE MAKE_COUNTRIES
AS
BEGIN
    FOR i IN 1..50000 LOOP
        INSERT INTO COUNTRIES (COUNTRY_ID, NAME, LANGUAGE, CURRENCY)
        VALUES (COUNTRIES_SEQ.NEXTVAL, 'Country ' || i, 'Lang ' || i, 'Cur ' || i);
    END LOOP;
    COMMIT;
END;

CREATE OR REPLACE PROCEDURE MAKE_CITIES
AS
BEGIN
    FOR i IN 1..50000 LOOP
        INSERT INTO CITIES (CITY_ID, NAME, POPULATION, CITY_SIZE, COUNTRY_ID)
        VALUES (
            CITIES_SEQ.NEXTVAL,
            'City ' || i,
            dbms_random.value(10, 1000), -- Random population
            dbms_random.value(50, 1000),     -- Random size
            dbms_random.value(1, 50000)         -- Random country_id (assuming 10 countries)
        );
    END LOOP;
    COMMIT;
END;

CREATE OR REPLACE PROCEDURE MAKE_ADDRESSES
AS
BEGIN
    FOR i IN 1..50000 LOOP
        INSERT INTO ADDRESSES (ADDRESS_ID, STREET, POSTAL_CODE, CITY_ID)
        VALUES (
            ADDRESSES_SEQ.NEXTVAL,
            'Street ' || i,
            dbms_random.value(10000, 99999), -- Random postal code
            dbms_random.value(1, 50000)         -- Random city_id (assuming 50 cities)
        );
    END LOOP;
    COMMIT;
END;
/






CREATE OR REPLACE TYPE review_type AS OBJECT (
    REVIEW_ID    NUMBER,
    COTTAGE_ID   NUMBER,
    AUTHOR_ID    NUMBER,
    TEXT         VARCHAR2(1000),
    DATE_POSTED  DATE,
    GRADE        NUMBER
);
/

CREATE OR REPLACE PROCEDURE CHANGE_REVIEW (P_REVIEW_ID LONG, P_COTTAGE_ID LONG)
AS
    V_REVIEW NUMBER (4);
BEGIN
    UPDATE REVIEWS
    SET COTTAGE_ID = P_COTTAGE_ID
    WHERE REVIEW_ID = P_REVIEW_ID;
END;

CREATE OR REPLACE PROCEDURE EXCHANGE_COTTAGES (FIRST_COTTAGE_ID LONG, SECOND_COTTAGE_ID LONG)
AS
    V_BASE_PRICE DECIMAL(7, 2) := 39.99;
    V_FIRST_OWNER LONG;
    V_SECOND_OWNER LONG;
BEGIN
    SELECT OWNER_ID INTO V_FIRST_OWNER FROM COTTAGES
    WHERE COTTAGE_ID = FIRST_COTTAGE_ID;

    SELECT OWNER_ID INTO V_SECOND_OWNER FROM COTTAGES
    WHERE COTTAGE_ID = SECOND_COTTAGE_ID;

    UPDATE COTTAGES
    SET MIN_PRICE_PER_DAY = V_BASE_PRICE, OWNER_ID = V_SECOND_OWNER
    WHERE COTTAGE_ID = FIRST_COTTAGE_ID;

    UPDATE COTTAGES
    SET MIN_PRICE_PER_DAY = V_BASE_PRICE, OWNER_ID = V_FIRST_OWNER
    WHERE COTTAGE_ID = SECOND_COTTAGE_ID;
END;

CREATE OR REPLACE PROCEDURE REMOVE_OLD_REQUESTS(REJECTED_THRESHOLD NUMBER, INACTIVE_THRESHOLD NUMBER)
AS
BEGIN
    DELETE FROM REQUESTS
    WHERE REQUEST_ID IN (
        SELECT R.REQUEST_ID
        FROM REQUESTS R
        JOIN REQUEST_APPROVALS RA ON R.REQUEST_ID = RA.REQUEST_ID
        WHERE RA.IS_APPROVED = 0
          AND RA.DATE_CREATED < SYSDATE - REJECTED_THRESHOLD
    );

    DELETE FROM REQUESTS
    WHERE REQUEST_ID NOT IN (
        SELECT REQUEST_ID
        FROM REQUEST_APPROVALS
    )
      AND CHECKIN_DATE < SYSDATE - INACTIVE_THRESHOLD;

END;

-- PROCEDURE CHECK
BEGIN
  MAKE_reviews (1);
END;
BEGIN
  MAKE_cottages (1);
END;

SELECT COUNT(*) FROM REVIEWS WHERE COTTAGE_ID = 1;
COMMIT WORK;

BEGIN
  CHANGE_REVIEW (5, 3);
END;

SELECT * FROM REVIEWS;

BEGIN
  EXCHANGE_COTTAGES (4, 5);
END;

SELECT * FROM COTTAGES;

BEGIN
  REMOVE_OLD_REQUESTS(7, 180);
END;

SELECT * FROM COTTAGES;

-- -- ---------TRIGGERS
CREATE OR REPLACE TRIGGER TG_REVIEW_TEXT
BEFORE INSERT on REVIEWS FOR EACH ROW
when (new.TEXT IS NULL)
DECLARE
    V_COTTAGE_NAME VARCHAR2(50);
BEGIN
    SELECT NAME INTO V_COTTAGE_NAME FROM COTTAGES
        WHERE COTTAGE_ID = :NEW.COTTAGE_ID;

    :NEW.TEXT :=
        CASE :NEW.GRADE
            WHEN  1
            THEN 'Very Bad Cottage.'
            WHEN 2
            THEN 'Bad Cottage.'
            WHEN 3
            THEN 'Decent Cottage.'
            WHEN 4
            THEN 'Good Cottage, I recommend.'
            WHEN 5
            THEN 'Great Cottage, I highly recommend.'
        END;

    dbms_output.put_line('new REVIEW added with grade ' || :NEW.GRADE || ' to cottage ' || V_COTTAGE_NAME);
END;

CREATE OR REPLACE TRIGGER TG_CALCULATE_TOTAL_PRICE
BEFORE INSERT OR UPDATE ON REQUESTS
FOR EACH ROW
WHEN (new.TOTAL_PRICE is null)
DECLARE
    V_DAILY_PRICE DECIMAL(7,2);
    V_DAYS NUMBER;
BEGIN
    SELECT MIN_PRICE_PER_DAY INTO V_DAILY_PRICE
    FROM COTTAGES
    WHERE COTTAGE_ID = :NEW.COTTAGE_ID;

    V_DAYS := :NEW.CHECKOUT_DATE - :NEW.CHECKIN_DATE;
    :NEW.TOTAL_PRICE := V_DAILY_PRICE * V_DAYS;
END;

CREATE OR REPLACE TRIGGER TG_COTTAGE_FIELDS
BEFORE INSERT ON COTTAGES FOR EACH ROW
WHEN (NEW.SIZE_M2 IS NOT NULL )
BEGIN

    IF :NEW.MAX_PEOPLE_NUM IS NULL THEN
        :NEW.MAX_PEOPLE_NUM := FLOOR(:NEW.SIZE_M2/25);
    END IF;

    IF :NEW.ROOMS_NUMBER IS NULL THEN
        :NEW.ROOMS_NUMBER := FLOOR(:NEW.SIZE_M2/30);
    END IF;

    IF :NEW.BATHROOMS_NUMBER IS NULL THEN
        :NEW.BATHROOMS_NUMBER := FLOOR(:NEW.SIZE_M2/50);
    END IF;
END;

-- TRIGER CHECK
UPDATE COTTAGES
SET MIN_PRICE_PER_DAY = 300
WHERE COTTAGE_ID = 2;

INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, CUSTOMER_ID) VALUES (7, 3, TO_DATE('2025-01-01','YYYY-MM-DD'), TO_DATE('2025-01-11','YYYY-MM-DD'), 1);
SELECT * FROM REQUESTS WHERE REQUEST_ID=7;

INSERT INTO REVIEWS (REVIEW_ID, COTTAGE_ID, AUTHOR_ID, TEXT, DATE_POSTED, GRADE)
    VALUES (27, 2, 1, NULL, TO_DATE('2024-11-10','YYYY-MM-DD'), 3);

SELECT * FROM REVIEWS;

INSERT INTO ADDRESSES VALUES(9, 'Magical street 77',  '07-777', 9);
INSERT INTO COTTAGES VALUES(9, 3, 79, 9, NULL, NULL, 1, NULL, 1);

SELECT * FROM COTTAGES;
-- -- ---------CURSORS
DROP PROCEDURE SHOW_AVG_PRICE_PER_USER;

CREATE OR REPLACE PROCEDURE SHOW_AVG_PRICE_PER_USER
IS
    CURSOR USER_CURSOR IS
        SELECT AVG(MIN_PRICE_PER_DAY) AS AVG_PRICE, OWNER_ID
        FROM COTTAGES
        GROUP BY OWNER_ID;

    USER_RECORD USER_CURSOR%ROWTYPE;

BEGIN
    -- OPEN USER_CURSOR;

    FOR USER_RECORD IN USER_CURSOR LOOP
        INSERT INTO AVG_PRICE_PER_USER (OWNER_ID, AVG_PRICE) VALUES (USER_RECORD.OWNER_ID, USER_RECORD.AVG_PRICE);
        DBMS_OUTPUT.PUT_LINE('OWNER ID: ' || USER_RECORD.OWNER_ID ||
            ' AVG PRICE: ' || USER_RECORD.AVG_PRICE);
    END LOOP;
    -- CLOSE USER_CURSOR;
END SHOW_AVG_PRICE_PER_USER;

CREATE OR REPLACE PROCEDURE SHOW_AVG_GRADE
IS
    CURSOR AVERAGE_GRADE_CR IS
        SELECT c.NAME, AVG(r.GRADE) AS AVG_GRADE
        FROM COTTAGES c
        JOIN REVIEWS r ON c.COTTAGE_ID = r.COTTAGE_ID
        GROUP BY c.NAME
        ORDER BY AVG_GRADE DESC;

    V_NAME VARCHAR2(100);
    V_AVG_GRADE NUMBER;
BEGIN
    OPEN AVERAGE_GRADE_CR;
    LOOP
        FETCH AVERAGE_GRADE_CR INTO V_NAME, V_AVG_GRADE;
        EXIT WHEN AVERAGE_GRADE_CR%NOTFOUND;
        INSERT INTO AVG_GRADE (COTTAGE_NAME, AVG_GRADE) VALUES (V_NAME, V_AVG_GRADE);
        DBMS_OUTPUT.PUT_LINE('Cottage: ' || V_NAME || ' - Average Grade: ' || V_AVG_GRADE);
    END LOOP;

    CLOSE AVERAGE_GRADE_CR;
END SHOW_AVG_GRADE;

CREATE OR REPLACE PROCEDURE SHOW_REQUEST_PER_CITY
IS
    CURSOR CITY_REQ_CR IS
        SELECT ci.name AS city_name,
               COUNT(r.request_id) AS total_requests
        FROM requests r
        JOIN cottages c ON r.cottage_id = c.cottage_id
        JOIN addresses a ON c.address_id = a.address_id
        JOIN cities ci ON a.city_id = ci.city_id
        GROUP BY ci.name;

    V_NAME VARCHAR2(20);
    V_TOTAL_REQ NUMBER;
BEGIN
    OPEN CITY_REQ_CR;
    LOOP
        FETCH CITY_REQ_CR INTO V_NAME, V_TOTAL_REQ;
        EXIT WHEN CITY_REQ_CR%NOTFOUND;
        INSERT INTO REQUEST_PER_CITY (CITY_NAME, TOTAL_REQ) VALUES (V_NAME, V_TOTAL_REQ);
        DBMS_OUTPUT.PUT_LINE('City: ' || V_NAME || ' - Total requests: ' || V_TOTAL_REQ);
    END LOOP;

    CLOSE CITY_REQ_CR;
END SHOW_REQUEST_PER_CITY;

-- CHECK CURSOR
EXEC SHOW_AVG_PRICE_PER_USER;
SELECT * FROM AVG_PRICE_PER_USER;


BEGIN
    SHOW_AVG_GRADE();
END;
SELECT * FROM AVG_GRADE;

EXEC SHOW_REQUEST_PER_CITY;
SELECT * FROM REQUEST_PER_CITY;

-- TESTS
SELECT COUNT(*), CITIES.NAME FROM COTTAGES
    JOIN ADDRESSES USING (ADDRESS_ID)
    LEFT JOIN CITIES USING (CITY_ID)
GROUP BY CITIES.NAME
HAVING COUNT(*) < 2;

SELECT c.NAME, COUNT(r.REQUEST_ID) REQUEST_COUNT, COUNT(ra.REQUEST_APPROVAL_ID) APPROVED_COUNT
FROM COTTAGES c
LEFT JOIN REQUESTS r ON c.COTTAGE_ID = r.COTTAGE_ID
LEFT JOIN REQUEST_APPROVALS ra ON r.REQUEST_ID = ra.REQUEST_ID AND ra.IS_APPROVED = 1
GROUP BY c.NAME
ORDER BY REQUEST_COUNT DESC;

SELECT COUNTRIES.NAME, COUNT(*) FROM COTTAGES
    JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    GROUP BY COUNTRY_ID, COUNTRIES.NAME
    ORDER BY COUNTRIES.NAME ASC;

SELECT GRADE, COUNT(REVIEW_ID) FROM REVIEWS
    LEFT JOIN COTTAGES USING (COTTAGE_ID)
    LEFT JOIN ADDRESSES USING (ADDRESS_ID)
    LEFT JOIN CITIES USING (CITY_ID)
    WHERE CITIES.NAME = 'Warsaw'
    GROUP BY REVIEWS.GRADE
    ORDER BY GRADE DESC;

SELECT USERNAME AS NAME ,COUNT(COTTAGE_ID) FROM COTTAGES
    RIGHT JOIN USERS ON COTTAGES.OWNER_ID = USERS.USER_ID
    GROUP BY USERNAME
    ORDER BY COUNT(COTTAGE_ID) DESC
    FETCH FIRST 2 ROWS ONLY;

-- OPTIMALIZATION TESTS
alter session set optimizer_mode = first_rows;
exec make_cottages(1);
EXPLAIN PLAN FOR


select count(*) from reviews ;
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
select * from cottages;

EXPLAIN PLAN FOR
SELECT OWNER_ID, COUNT(*) FROM COTTAGES GROUP BY OWNER_ID HAVING COUNT (*) > 2;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

EXPLAIN PLAN FOR
SELECT COUNTRIES.NAME, COUNT(*) FROM COTTAGES
    JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    GROUP BY COUNTRY_ID, COUNTRIES.NAME;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

------------TEST DATA TERMINATED
DELETE FROM REQUEST_APPROVALS WHERE REQUEST_APPROVAL_ID in (1, 2, 3);
DELETE FROM REQUESTS WHERE REQUEST_ID IN (1, 2, 3, 7);