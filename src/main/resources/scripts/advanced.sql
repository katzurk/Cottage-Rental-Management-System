------------TEST DATA
INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    VALUES (1, 1, TO_DATE('2025-01-01','YYYY-MM-DD'), TO_DATE('2025-01-02','YYYY-MM-DD'), 1, 1);
INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    VALUES (12, 1, TO_DATE('2025-01-30','YYYY-MM-DD'), TO_DATE('2025-02-02','YYYY-MM-DD'), 1, 1);
INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, TOTAL_PRICE, CUSTOMER_ID)
    VALUES (3, 1, TO_DATE('2025-01-01','YYYY-MM-DD'), TO_DATE('2025-01-11','YYYY-MM-DD'), 10, 1);
INSERT INTO REQUEST_APPROVALS (REQUEST_APPROVAL_ID, DATE_CREATED, IS_APPROVED, REQUEST_ID) VALUES (1, SYSDATE, 1, 1);
INSERT INTO REQUEST_APPROVALS (REQUEST_APPROVAL_ID, DATE_CREATED, IS_APPROVED, REQUEST_ID) VALUES (2, TO_DATE('2025-01-01','YYYY-MM-DD'), 0, 3);

-- ---------FUNCTIONS  -> IN ORACLE
CREATE OR REPLACE FUNCTION IS_GRADE_GOOD(V_GRADE NUMBER)
RETURN NUMBER
AS
    V_RESULT NUMBER;
BEGIN
    IF V_GRADE > 3 THEN
        V_RESULT := 1;
    ELSE
        V_RESULT := 0;
    END IF;
    RETURN V_RESULT;
END;

CREATE OR REPLACE FUNCTION REQUEST_STATUS(P_REQUEST_ID NUMBER)
RETURN VARCHAR2
AS
    V_EXISTS NUMBER;
    V_IS_APPROVED NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_EXISTS
    FROM REQUEST_APPROVALS
    WHERE REQUEST_ID = P_REQUEST_ID;
    IF V_EXISTS > 0 THEN
       SELECT IS_APPROVED INTO V_IS_APPROVED
       FROM REQUEST_APPROVALS
       WHERE REQUEST_ID = P_REQUEST_ID;

        IF V_IS_APPROVED = 1 THEN
           RETURN 'Accepted';
        ELSE
           RETURN 'Rejected';
        END IF;
    ELSE
        RETURN 'Pending';
    END IF;
END;

CREATE OR REPLACE FUNCTION CALCULATE_TOTAL_TAX(P_REQUEST_ID NUMBER)
RETURN NUMBER
AS
  V_DAYS  NUMBER;
  V_TOTAL_PRICE  DECIMAL(7, 2) := 0;
  V_PRICE_PER_DAY DECIMAL(7, 2);
  V_COTTAGE_ID NUMBER;
  V_TOTAL_TAX DECIMAL(7, 2) := 0;
  V_FIRST_WEEK_TAX DECIMAL(7, 2) := 0;
  V_SECOND_WEEK_TAX DECIMAL(7, 2) := 0;
BEGIN
    SELECT (CHECKOUT_DATE - CHECKIN_DATE), COTTAGE_ID
    INTO   V_DAYS, V_COTTAGE_ID
    FROM   REQUESTS
    WHERE  REQUEST_id = P_REQUEST_ID;

    SELECT MIN_PRICE_PER_DAY
    INTO V_PRICE_PER_DAY
    FROM COTTAGES
    WHERE COTTAGE_ID = V_COTTAGE_ID;

    V_TOTAL_PRICE := V_DAYS * V_PRICE_PER_DAY;
    V_FIRST_WEEK_TAX := 0.36 * 7 + 0.33 * 7* V_PRICE_PER_DAY;
    V_SECOND_WEEK_TAX := 0.26 * 7 + 0.23 * 7* V_PRICE_PER_DAY;
    IF V_DAYS = 1 THEN
        V_TOTAL_TAX := 10;
    ELSIF V_DAYS < 7 THEN
        V_TOTAL_TAX := 0.36 * V_DAYS + 0.33 * V_TOTAL_PRICE;
    ELSIF V_DAYS < 14 THEN
        V_TOTAL_TAX := V_FIRST_WEEK_TAX + 0.26 * (V_DAYS - 7) + 0.23 * (V_DAYS - 7) * V_PRICE_PER_DAY;
    ELSE
        V_TOTAL_TAX := V_FIRST_WEEK_TAX + V_SECOND_WEEK_TAX + 0.15 * (V_DAYS - 14) + 0.12 * (V_DAYS - 14) * V_PRICE_PER_DAY;
    END IF;

    RETURN V_TOTAL_TAX;
END;


CREATE OR REPLACE FUNCTION AVG_PRICE_IN_COUNTRY_WITH_TAX (P_COUNTRY_ID LONG)
RETURN NUMBER
AS
  V_AVG_PRICE  DECIMAL(7, 2) := 0;
  V_MIN_PRICE  DECIMAL(7, 2) := 0;
  V_TOTAL_PRICE  DECIMAL(7, 2) := 0;
BEGIN
    SELECT AVG(TOTAL_PRICE) INTO V_AVG_PRICE
    FROM REQUESTS JOIN COTTAGES USING (COTTAGE_ID)
    JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    WHERE COUNTRY_ID = P_COUNTRY_ID;

    SELECT MIN(MIN_PRICE_PER_DAY) INTO V_MIN_PRICE
    FROM COTTAGES JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    WHERE COUNTRY_ID = P_COUNTRY_ID;

    IF V_MIN_PRICE > 30 THEN
        V_TOTAL_PRICE := V_AVG_PRICE + V_MIN_PRICE;
    ELSIF  V_MIN_PRICE > 10 THEN
        V_TOTAL_PRICE := V_AVG_PRICE + V_MIN_PRICE * 2;
    ELSE
        V_TOTAL_PRICE := V_AVG_PRICE;
    END IF;
    RETURN V_TOTAL_PRICE;
END;

--checks whether the cottage is available during the specified time
CREATE OR REPLACE FUNCTION is_cottage_available(
    p_cottage_id NUMBER,
    p_checkin_date DATE,
    p_checkout_date DATE
) RETURN number IS
    v_conflicting_requests NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_conflicting_requests
    FROM requests r
    JOIN request_approvals ra ON r.request_id = ra.request_id
    WHERE r.cottage_id = p_cottage_id
      AND ra.is_approved = 1
      AND (
           (r.checkin_date <= p_checkin_date AND r.checkout_date >= p_checkin_date) OR
           (r.checkin_date <= p_checkout_date AND r.checkout_date >= p_checkout_date) OR
           (r.checkin_date >= p_checkin_date AND r.checkout_date <= p_checkout_date)
      );

    IF v_conflicting_requests = 0 THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;
END;


-- FUNCTION CHECK
SELECT IS_GRADE_GOOD(5) from dual;
SELECT IS_GRADE_GOOD(3) from dual;

SELECT REQUEST_ID, REQUEST_STATUS(REQUEST_ID) AS STATUS FROM REQUESTS;

SELECT CALCULATE_TOTAL_TAX(1) FROM dual;
SELECT CALCULATE_TOTAL_TAX(4) FROM dual;

SELECT AVG_PRICE_IN_COUNTRY_WITH_TAX(1) FROM dual;

-- ---------PROCEDURES
CREATE OR REPLACE PROCEDURE CHANGE_REVIEW (P_REVIEW_ID LONG, P_COTTAGE_ID LONG)
AS
    V_REVIEW NUMBER (4);
BEGIN
    UPDATE REVIEWS
    SET COTTAGE_ID = P_COTTAGE_ID
    WHERE REVIEW_ID = P_REVIEW_ID;
END;

CREATE OR REPLACE PROCEDURE EXCHANGE_COTTAGES (FIRST_COTTAGE_ID LONG, SECOND_COTTAGE_ID LONG)
AS
    V_BASE_PRICE DECIMAL(7, 2) := 39.99;
    V_FIRST_OWNER LONG;
    V_SECOND_OWNER LONG;
BEGIN
    SELECT OWNER_ID INTO V_FIRST_OWNER FROM COTTAGES
    WHERE COTTAGE_ID = FIRST_COTTAGE_ID;

    SELECT OWNER_ID INTO V_SECOND_OWNER FROM COTTAGES
    WHERE COTTAGE_ID = SECOND_COTTAGE_ID;

    UPDATE COTTAGES
    SET MIN_PRICE_PER_DAY = V_BASE_PRICE, OWNER_ID = V_SECOND_OWNER
    WHERE COTTAGE_ID = FIRST_COTTAGE_ID;

    UPDATE COTTAGES
    SET MIN_PRICE_PER_DAY = V_BASE_PRICE, OWNER_ID = V_FIRST_OWNER
    WHERE COTTAGE_ID = SECOND_COTTAGE_ID;
END;

CREATE OR REPLACE PROCEDURE REMOVE_OLD_REQUESTS(REJECTED_THRESHOLD NUMBER, INACTIVE_THRESHOLD NUMBER)
AS
BEGIN
    DELETE FROM REQUESTS
    WHERE REQUEST_ID IN (
        SELECT R.REQUEST_ID
        FROM REQUESTS R
        JOIN REQUEST_APPROVALS RA ON R.REQUEST_ID = RA.REQUEST_ID
        WHERE RA.IS_APPROVED = 0
          AND RA.DATE_CREATED < SYSDATE - REJECTED_THRESHOLD
    );

    DELETE FROM REQUESTS
    WHERE REQUEST_ID NOT IN (
        SELECT REQUEST_ID
        FROM REQUEST_APPROVALS
    )
      AND CHECKIN_DATE < SYSDATE - INACTIVE_THRESHOLD;

END;

-- PROCEDURE CHECK
BEGIN
  CHANGE_REVIEW (5, 3);
END;

SELECT * FROM REVIEWS;

BEGIN
  EXCHANGE_COTTAGES (4, 5);
END;

SELECT * FROM COTTAGES;

BEGIN
  REMOVE_OLD_REQUESTS(7, 180);
END;

SELECT * FROM COTTAGES;

-- -- ---------TRIGGERS
CREATE OR REPLACE TRIGGER TG_REVIEW_TEXT
BEFORE INSERT on REVIEWS FOR EACH ROW
when (new.TEXT IS NULL)
DECLARE
    V_COTTAGE_NAME VARCHAR2(50);
BEGIN
    SELECT NAME INTO V_COTTAGE_NAME FROM COTTAGES
        WHERE COTTAGE_ID = :NEW.COTTAGE_ID;

    :NEW.TEXT :=
        CASE :NEW.GRADE
            WHEN  1
            THEN 'Very Bad Cottage.'
            WHEN 2
            THEN 'Bad Cottage.'
            WHEN 3
            THEN 'Decent Cottage.'
            WHEN 4
            THEN 'Good Cottage, I recommend.'
            WHEN 5
            THEN 'Great Cottage, I highly recommend.'
        END;

    dbms_output.put_line('new REVIEW added with grade ' || :NEW.GRADE || ' to cottage ' || V_COTTAGE_NAME);
END;

CREATE OR REPLACE TRIGGER TG_CALCULATE_TOTAL_PRICE
BEFORE INSERT OR UPDATE ON REQUESTS
FOR EACH ROW
WHEN (new.TOTAL_PRICE is null)
DECLARE
    V_DAILY_PRICE DECIMAL(7,2);
    V_DAYS NUMBER;
BEGIN
    SELECT MIN_PRICE_PER_DAY INTO V_DAILY_PRICE
    FROM COTTAGES
    WHERE COTTAGE_ID = :NEW.COTTAGE_ID;

    V_DAYS := :NEW.CHECKOUT_DATE - :NEW.CHECKIN_DATE;
    :NEW.TOTAL_PRICE := V_DAILY_PRICE * V_DAYS;
END;

CREATE OR REPLACE TRIGGER TG_COTTAGE_FIELDS
BEFORE INSERT ON COTTAGES FOR EACH ROW
WHEN (NEW.SIZE_M2 IS NOT NULL )
BEGIN

    IF :NEW.MAX_PEOPLE_NUM IS NULL THEN
        :NEW.MAX_PEOPLE_NUM := FLOOR(:NEW.SIZE_M2/25);
    END IF;

    IF :NEW.ROOMS_NUMBER IS NULL THEN
        :NEW.ROOMS_NUMBER := FLOOR(:NEW.SIZE_M2/30);
    END IF;

    IF :NEW.BATHROOMS_NUMBER IS NULL THEN
        :NEW.BATHROOMS_NUMBER := FLOOR(:NEW.SIZE_M2/50);
    END IF;
END;

-- TRIGER CHECK
UPDATE COTTAGES
SET MIN_PRICE_PER_DAY = 300
WHERE COTTAGE_ID = 2;

INSERT INTO REQUESTS (REQUEST_ID, COTTAGE_ID, CHECKIN_DATE, CHECKOUT_DATE, CUSTOMER_ID) VALUES (7, 3, TO_DATE('2025-01-01','YYYY-MM-DD'), TO_DATE('2025-01-11','YYYY-MM-DD'), 1);
SELECT * FROM REQUESTS WHERE REQUEST_ID=7;

INSERT INTO REVIEWS (REVIEW_ID, COTTAGE_ID, AUTHOR_ID, TEXT, DATE_POSTED, GRADE)
    VALUES (27, 2, 1, NULL, TO_DATE('2024-11-10','YYYY-MM-DD'), 3);

SELECT * FROM REVIEWS;

INSERT INTO ADDRESSES VALUES(9, 'Magical street 77',  '07-777', 9);
INSERT INTO COTTAGES VALUES(9, 3, 79, 9, NULL, NULL, 1, NULL, 1);

SELECT * FROM COTTAGES;
-- -- ---------CURSORS
DROP PROCEDURE SHOW_AVG_PRICE_PER_USER;
CREATE OR REPLACE PROCEDURE SHOW_AVG_PRICE_PER_USER
IS
    CURSOR USER_CURSOR IS
        SELECT AVG(MIN_PRICE_PER_DAY) AS AVG_PRICE, OWNER_ID
        FROM COTTAGES
        GROUP BY OWNER_ID;

    USER_RECORD USER_CURSOR%ROWTYPE;

BEGIN
    -- OPEN USER_CURSOR;

    FOR USER_RECORD IN USER_CURSOR LOOP
        DBMS_OUTPUT.PUT_LINE('OWNER ID: ' || USER_RECORD.OWNER_ID ||
            ' AVG PRICE: ' || USER_RECORD.AVG_PRICE);
    END LOOP;
    -- CLOSE USER_CURSOR;
END SHOW_AVG_PRICE_PER_USER;

CREATE OR REPLACE PROCEDURE SHOW_AVG_GRADE
IS
    CURSOR AVERAGE_GRADE_CR IS
        SELECT c.NAME, AVG(r.GRADE) AS AVG_GRADE
        FROM COTTAGES c
        JOIN REVIEWS r ON c.COTTAGE_ID = r.COTTAGE_ID
        GROUP BY c.NAME
        ORDER BY AVG_GRADE DESC;

    V_NAME VARCHAR2(20);
    V_AVG_GRADE NUMBER;
BEGIN
    OPEN AVERAGE_GRADE_CR;
    LOOP
        FETCH AVERAGE_GRADE_CR INTO V_NAME, V_AVG_GRADE;
        EXIT WHEN AVERAGE_GRADE_CR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Cottage: ' || V_NAME || ' - Average Grade: ' || V_AVG_GRADE);
    END LOOP;

    CLOSE AVERAGE_GRADE_CR;
END SHOW_AVG_GRADE;

CREATE OR REPLACE PROCEDURE SHOW_REQUEST_PER_CITY
IS
    CURSOR CITY_REQ_CR IS
        SELECT ci.name AS city_name,
               COUNT(r.request_id) AS total_requests
        FROM requests r
        JOIN cottages c ON r.cottage_id = c.cottage_id
        JOIN addresses a ON c.address_id = a.address_id
        JOIN cities ci ON a.city_id = ci.city_id
        GROUP BY ci.name;

    V_NAME VARCHAR2(20);
    V_TOTAL_REQ NUMBER;
BEGIN
    OPEN CITY_REQ_CR_CR;
    LOOP
        FETCH CITY_REQ_CR INTO V_NAME, V_TOTAL_REQ;
        EXIT WHEN CITY_REQ_CR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('City: ' || V_NAME || ' - Total requests: ' || V_TOTAL_REQ);
    END LOOP;

    CLOSE CITY_REQ_CR;
END SHOW_REQUEST_PER_CITY;

-- CHECK CURSOR
EXEC SHOW_AVG_PRICE_PER_USER;

BEGIN
    SHOW_AVG_GRADE;
END;

EXEC SHOW_REQUEST_PER_CITY;

-- TESTS
SELECT COUNT(*), CITIES.NAME FROM COTTAGES
    JOIN ADDRESSES USING (ADDRESS_ID)
    LEFT JOIN CITIES USING (CITY_ID)
GROUP BY CITIES.NAME
HAVING COUNT(*) < 2;

SELECT c.NAME, COUNT(r.REQUEST_ID) REQUEST_COUNT, COUNT(ra.REQUEST_APPROVAL_ID) APPROVED_COUNT
FROM COTTAGES c
LEFT JOIN REQUESTS r ON c.COTTAGE_ID = r.COTTAGE_ID
LEFT JOIN REQUEST_APPROVALS ra ON r.REQUEST_ID = ra.REQUEST_ID AND ra.IS_APPROVED = 1
GROUP BY c.NAME
ORDER BY REQUEST_COUNT DESC;

SELECT COUNTRIES.NAME, COUNT(*) FROM COTTAGES
    JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    GROUP BY COUNTRY_ID, COUNTRIES.NAME
    ORDER BY COUNTRIES.NAME ASC;

SELECT GRADE, COUNT(REVIEW_ID) FROM REVIEWS
    LEFT JOIN COTTAGES USING (COTTAGE_ID)
    LEFT JOIN ADDRESSES USING (ADDRESS_ID)
    LEFT JOIN CITIES USING (CITY_ID)
    WHERE CITIES.NAME = 'Warsaw'
    GROUP BY REVIEWS.GRADE
    ORDER BY GRADE DESC;

SELECT USERNAME AS NAME ,COUNT(COTTAGE_ID) FROM COTTAGES
    RIGHT JOIN USERS ON COTTAGES.OWNER_ID = USERS.USER_ID
    GROUP BY USERNAME
    ORDER BY COUNT(COTTAGE_ID) DESC
    FETCH FIRST 2 ROWS ONLY;

-- OPTIMALIZATION TESTS
EXPLAIN PLAN FOR
SELECT * FROM COTTAGES;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());


EXPLAIN PLAN FOR
SELECT OWNER_ID, COUNT(*) FROM COTTAGES GROUP BY OWNER_ID HAVING COUNT (*) > 2;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

EXPLAIN PLAN FOR
SELECT COUNTRIES.NAME, COUNT(*) FROM COTTAGES
    JOIN ADDRESSES USING (ADDRESS_ID)
    JOIN CITIES USING (CITY_ID)
    JOIN COUNTRIES USING (COUNTRY_ID)
    GROUP BY COUNTRY_ID, COUNTRIES.NAME;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

------------TEST DATA TERMINATED
DELETE FROM REQUEST_APPROVALS WHERE REQUEST_APPROVAL_ID in (1, 2, 3);
DELETE FROM REQUESTS WHERE REQUEST_ID IN (1, 2, 3, 7);